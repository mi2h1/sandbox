<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MOTHER2 HP Drum</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #030712;
    }
    .drum-container {
      perspective: 150px;
      overflow: hidden;
      position: relative;
    }
    .drum-cylinder {
      position: absolute;
      width: 100%;
      top: 50%;
      transform-style: preserve-3d;
    }
    .drum-face {
      position: absolute;
      width: 100%;
      height: 32px;
      margin-top: -16px;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      font-family: monospace;
      font-weight: bold;
      font-size: 1.4rem;
      color: #4ade80;
    }
    .drum-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to bottom, 
        rgba(0,0,0,0.85) 0%, 
        rgba(0,0,0,0.4) 25%,
        transparent 45%,
        transparent 55%,
        rgba(0,0,0,0.4) 75%,
        rgba(0,0,0,0.85) 100%
      );
      pointer-events: none;
      border-radius: 4px;
    }
    .drum-highlight {
      position: absolute;
      inset: 0;
      background: linear-gradient(to right,
        rgba(255,255,255,0.03) 0%,
        rgba(255,255,255,0.08) 50%,
        rgba(255,255,255,0.03) 100%
      );
      pointer-events: none;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const FACE_COUNT = 10;
    const ANGLE_PER_FACE = 360 / FACE_COUNT;
    const RADIUS = 32;

    function DrumDigit({ digit, duration = 150 }) {
      const cylinderRef = useRef(null);
      const animationRef = useRef(null);
      const currentAngleRef = useRef(digit * -ANGLE_PER_FACE);

      useEffect(() => {
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
        }

        const startAngle = currentAngleRef.current;
        // 現在の正規化された角度から目標を計算
        const normalizedStart = ((startAngle % 360) + 360) % 360;
        const targetBase = digit * -ANGLE_PER_FACE;
        const normalizedTarget = ((targetBase % 360) + 360) % 360;
        
        // 最短距離を計算
        let diff = normalizedTarget - normalizedStart;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        const targetAngle = startAngle + diff;
        
        if (Math.abs(diff) < 0.1) return;

        const startTime = performance.now();

        function animate(currentTime) {
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // イーズアウト
          const eased = 1 - Math.pow(1 - progress, 2);
          
          const newAngle = startAngle + diff * eased;
          currentAngleRef.current = newAngle;
          
          if (cylinderRef.current) {
            cylinderRef.current.style.transform = `rotateX(${newAngle}deg)`;
          }

          if (progress < 1) {
            animationRef.current = requestAnimationFrame(animate);
          } else {
            currentAngleRef.current = targetAngle;
            if (cylinderRef.current) {
              cylinderRef.current.style.transform = `rotateX(${targetAngle}deg)`;
            }
          }
        }

        animationRef.current = requestAnimationFrame(animate);

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [digit, duration]);

      const faces = Array.from({ length: FACE_COUNT }, (_, i) => {
        const angle = i * ANGLE_PER_FACE;
        return {
          digit: i,
          style: {
            transform: `rotateX(${angle}deg) translateZ(${RADIUS}px)`,
          }
        };
      });

      return (
        <div className="drum-container w-12 h-16 bg-gray-900 border-2 border-gray-600 rounded">
          <div 
            ref={cylinderRef}
            className="drum-cylinder"
            style={{ 
              transform: `rotateX(${digit * -ANGLE_PER_FACE}deg)`,
            }}
          >
            {faces.map(({ digit: d, style }) => (
              <div key={d} className="drum-face" style={style}>
                {d}
              </div>
            ))}
          </div>
          <div className="drum-overlay"></div>
          <div className="drum-highlight"></div>
        </div>
      );
    }

    function DrumCounter({ value, digits = 4, tickInterval = 50 }) {
      const [displayValue, setDisplayValue] = useState(value);
      const targetRef = useRef(value);
      const intervalRef = useRef(null);

      useEffect(() => {
        targetRef.current = value;
        
        if (intervalRef.current) {
          return; // すでにアニメーション中なら継続
        }

        const tick = () => {
          setDisplayValue(prev => {
            const target = targetRef.current;
            if (prev === target) {
              clearInterval(intervalRef.current);
              intervalRef.current = null;
              return prev;
            }
            // 1ずつ増減
            return prev < target ? prev + 1 : prev - 1;
          });
        };

        if (displayValue !== value) {
          intervalRef.current = setInterval(tick, tickInterval);
        }

        return () => {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
        };
      }, [value, tickInterval]);

      // 途中で目標値が変わった場合に対応
      useEffect(() => {
        targetRef.current = value;
        
        if (!intervalRef.current && displayValue !== value) {
          const tick = () => {
            setDisplayValue(prev => {
              const target = targetRef.current;
              if (prev === target) {
                clearInterval(intervalRef.current);
                intervalRef.current = null;
                return prev;
              }
              return prev < target ? prev + 1 : prev - 1;
            });
          };
          intervalRef.current = setInterval(tick, tickInterval);
        }
      }, [value]);

      const paddedValue = String(Math.max(0, displayValue)).padStart(digits, '0');
      const digitArray = paddedValue.split('').map(Number);

      return (
        <div className="flex gap-1 p-3 bg-gray-800 rounded-lg shadow-inner">
          {digitArray.map((d, i) => (
            <DrumDigit 
              key={i} 
              digit={d} 
              duration={120}
            />
          ))}
        </div>
      );
    }

    function App() {
      const [hp, setHp] = useState(999);
      const maxHp = 999;

      const takeDamage = (amount) => setHp(prev => Math.max(0, prev - amount));
      const heal = (amount) => setHp(prev => Math.min(maxHp, prev + amount));

      return (
        <div className="min-h-screen flex flex-col items-center justify-center gap-8 p-8">
          <h1 className="text-3xl font-bold text-yellow-400 tracking-wider">
            MOTHER2 HP DRUM
          </h1>

          <div className="flex flex-col items-center gap-4">
            <div className="text-gray-400 text-sm tracking-widest">HP</div>
            <DrumCounter value={hp} digits={4} tickInterval={40} />
            <div className="text-gray-500 text-xs">/ {maxHp}</div>
          </div>

          <div className="flex flex-wrap gap-3 justify-center">
            <button
              onClick={() => takeDamage(50)}
              className="px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded font-bold transition-colors"
            >
              -50 ダメージ
            </button>
            <button
              onClick={() => takeDamage(150)}
              className="px-4 py-2 bg-red-700 hover:bg-red-600 text-white rounded font-bold transition-colors"
            >
              -150 大ダメージ
            </button>
            <button
              onClick={() => takeDamage(500)}
              className="px-4 py-2 bg-red-900 hover:bg-red-800 text-white rounded font-bold transition-colors"
            >
              -500 致命傷！
            </button>
            <button
              onClick={() => heal(100)}
              className="px-4 py-2 bg-green-600 hover:bg-green-500 text-white rounded font-bold transition-colors"
            >
              +100 回復
            </button>
            <button
              onClick={() => setHp(maxHp)}
              className="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold transition-colors"
            >
              全回復
            </button>
          </div>

          <p className="text-gray-500 text-sm max-w-md text-center">
            致命傷を受けても、HPが0になる前に回復ボタンを押せば助かる...かも？
          </p>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
